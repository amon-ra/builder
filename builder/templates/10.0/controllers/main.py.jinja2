import json
from odoo import http, fields, SUPERUSER_ID
from odoo.http import request
from odoo.addons.http_routing.models.ir_http import slug, unslug
from odoo.addons.website.controllers.main import QueryURL


class {{ page.xml_id }}(http.Controller):

    @http.route([{{ controller_routes }}], type='http', 
                auth="{{ page.visibility }}", methods=['GET'], website={{ page.attr_page }}, csrf={{ page.csrf }} )
    def page{{ loop.index }}({{ route_parameters }},**kwargs):
        """
        date_begin, date_end, state = kwargs.get('date_begin'), kwargs.get('date_end'), kwargs.get('state')
        published_count, unpublished_count = 0, 0
        domain = request.website.website_domain()  
        domain = request.website.website_domain()
        blog_post = request.env['blog.post']
        blogs = request.env['blog.blog'].search(domain, order="create_date asc", limit=2)
        if blog:
            domain += [('blog_id', '=', blog.id)]
        if date_begin and date_end:
            domain += [("post_date", ">=", date_begin), ("post_date", "<=", date_end)]
        if request.env.user.has_group('website.group_website_designer'):
            count_domain = domain + [("website_published", "=", True), ("post_date", "<=", fields.Datetime.now())]
            published_count = blog_post.search_count(count_domain)
            unpublished_count = blog_post.search_count(domain) - published_count

            if state == "published":
                domain += [("website_published", "=", True), ("post_date", "<=", fields.Datetime.now())]
            elif state == "unpublished":
                domain += ['|', ("website_published", "=", False), ("post_date", ">", fields.Datetime.now())]
        else:
            domain += [("post_date", "<=", fields.Datetime.now())]

        blog_url = QueryURL('', ['blog', 'tag'], blog=blog, tag=tag, date_begin=date_begin, date_end=date_end)

        search_string = opt.get('search', None)

        blog_posts = blog_post.search([('name', 'ilike', search_string)],
                                      offset=(page - 1) * self._blog_post_per_page,
                                      limit=self._blog_post_per_page) if search_string \
            else blog_post.search(domain,
                                  order="post_date desc")

        pager = request.website.pager(
            url=request.httprequest.path.partition('/page/')[0],
            total=len(blog_posts),
            page=page,
            step=self._blog_post_per_page,
            url_args=opt,
        ) 
        pager_begin = (page - 1) * self._blog_post_per_page
        pager_end = page * self._blog_post_per_page
        blog_posts = blog_posts[pager_begin:pager_end]
        use_cover = request.website.viewref('website_blog.opt_blog_cover_post').active
        fullwidth_cover = request.website.viewref('website_blog.opt_blog_cover_post_fullwidth_design').active
        offset = (page - 1) * self._blog_post_per_page
        first_post = blog_posts
        if not blog:
            first_post = blog_posts.search(domain + [('website_published', '=', True)], order="post_date desc, id asc",
                                           limit=1)
            if use_cover and not fullwidth_cover:
                offset += 1
        values = {
            'blog': blog,
            'blogs': blogs,
            'first_post': first_post.with_prefetch(blog_posts.ids) if not search_string else None,
            'other_tags': other_tags,
            'state_info': {"state": state, "published": published_count, "unpublished": unpublished_count},
            'active_tag_ids': active_tag_ids,
            'posts': blog_posts,
            'blog_posts_cover_properties': [json.loads(b.cover_properties) for b in blog_posts],
            'pager': pager,
            'nav_list': self.nav_list(blog),
            'blog_url': blog_url,
            'date': date_begin,
            'tag_category': tag_category,
        }

        """
        values = {}
        return request.render('{{ page.module_id.name }}.{{ page.attr_id }}', values)

